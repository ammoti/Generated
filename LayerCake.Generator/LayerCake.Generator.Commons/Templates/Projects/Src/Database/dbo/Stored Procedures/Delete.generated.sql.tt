<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ parameter name="Context" type="LayerCake.Generator.Commons.TextTemplatingProcessContext" #>
<#@ include file="Commons/Includes.ttinclude" #>
<#
	bool? bForceSeparator = null;
#>
-- ------------------------------------------------------------------------------ 
-- <auto-generated> 
-- This code was generated by LayerCake Generator v3.7.1.
-- http://www.layercake-generator.net
-- 
-- Changes to this file may cause incorrect behavior AND WILL BE LOST IF 
-- the code is regenerated. 
-- </auto-generated> 
-- ------------------------------------------------------------------------------

CREATE PROCEDURE <#=Context.Table.Name#>_Delete
(
	@<#=Context.Table.Name#>_Id BIGINT,

	@CtxUser BIGINT = NULL,
	@CtxCulture VARCHAR(2) = N'<#=Context.ProcessorContext.Culture.Default#>',
	@CtxWithContextSecurity BIT = N'True'
)
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN TRANSACTION;

<#
	if (Context.Table.IsOwnership)
	{
#>
			DECLARE @V_COUNTER INT = 1;

			IF @CtxWithContextSecurity = N'True'
			BEGIN

				SELECT	@V_COUNTER = 1
				FROM	[<#=Context.Table.Name#>] <#=WithNoLockOption(Context.ProcessorContext)#>
				WHERE	[<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Id] = @<#=Context.Table.Name#>_Id AND [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Owner] = @CtxUser;

			END

			IF @V_COUNTER = 0
			BEGIN

				IF EXISTS(	SELECT	COUNT(0)
							FROM	[<#=Context.Table.Name#>] <#=WithNoLockOption(Context.ProcessorContext)#>
							WHERE	[<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Id] = @<#=Context.Table.Name#>_Id AND [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Owner] != @CtxUser)
				BEGIN

					DECLARE @V_OWNER BIGINT;
					SELECT @V_OWNER = [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Owner] FROM [<#=Context.Table.Name#>] <#=WithNoLockOption(Context.ProcessorContext)#> WHERE [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Id] = @<#=Context.Table.Name#>_Id;
					
					IF @V_OWNER != 0
					BEGIN

						RAISERROR(N'OwnerException on <#=Context.Table.Name#>.Id = %I64d (Owner = %I64d, Requested User = %I64d)', 16, 1, @<#=Context.Table.Name#>_Id, @V_OWNER, @CtxUser);
						RETURN (@@ROWCOUNT);

					END

				END

			END
<#
	}
#>
			DECLARE @V_ROWCOUNT INT = 0;
			DECLARE @V_IS_LOCKED BIT = N'False';

<#
	if (Context.Table.IsOwnership)
	{
#>
			SELECT @V_IS_LOCKED = [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_IsLocked] FROM [<#=Context.Table.Name#>] <#=WithNoLockOption(Context.ProcessorContext)#> WHERE [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Id] = @<#=Context.Table.Name#>_Id;
<#
	}
#>
			IF (@V_IS_LOCKED = N'False')
			BEGIN

				IF (EXISTS(	SELECT	TOP 1 1
							FROM	[sys].[tables] <#=WithNoLockOption(Context.ProcessorContext)#>
							WHERE	[name] = N'<#=Context.Table.Name#>_LOGS'))
				BEGIN

					DECLARE @V_LOG_QUERY NVARCHAR(MAX) = 
						  N' INSERT INTO [<#=Context.Table.Name#>_LOGS]'
						+ N' ('
<#
	bForceSeparator = null;
	for (int i = 0; i < Context.Table.Columns.Length; i++)
	{
		if (Context.Table.Columns[i].IsLanguageColumn)
		{
			for (int j = 0; j < Context.ProcessorContext.Culture.SupportedCultures.Length; j++)
			{
#>
						+ N' <#bForceSeparator = WithStartSeparator(bForceSeparator); if (bForceSeparator.Value) { #>,<# } else { #> <# }#>[<#=Context.Table.Name#>_LOGS].[<#=Context.Table.Columns[i].Name#>_<#=Context.ProcessorContext.Culture.SupportedCultures[j]#>]'
<#
			}
		}
		else
		{
#>
						+ N' <#bForceSeparator = WithStartSeparator(bForceSeparator); if (bForceSeparator.Value) { #>,<# } else { #> <# }#>[<#=Context.Table.Name#>_LOGS].[<#=Context.Table.Columns[i].Name#>]'
<#
		}
	}
#>
						+ N' )'
						+ N' SELECT'
<#
	bForceSeparator = null;
	for (int i = 0; i < Context.Table.Columns.Length; i++)
	{
		if (Context.Table.Columns[i].IsLanguageColumn)
		{
			for (int j = 0; j < Context.ProcessorContext.Culture.SupportedCultures.Length; j++)
			{
#>
						+ N' <#bForceSeparator = WithStartSeparator(bForceSeparator); if (bForceSeparator.Value) { #>,<# } else { #> <# }#>[<#=Context.Table.Name#>].[<#=Context.Table.Columns[i].Name#>_<#=Context.ProcessorContext.Culture.SupportedCultures[j]#>]'
<#
			}
		}
		else
		{
#>
						+ N' <#bForceSeparator = WithStartSeparator(bForceSeparator); if (bForceSeparator.Value) { #>,<# } else { #> <# }#>[<#=Context.Table.Name#>].[<#=Context.Table.Columns[i].Name#>]'
<#
		}
	}
#>
						+ N' FROM'
						+ N' [<#=Context.Table.Name#>] <#=WithNoLockOption(Context.ProcessorContext)#>'
						+ N' WHERE'
						+ N' [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Id] = @<#=Context.Table.Name#>_Id;';

					EXECUTE sp_executesql @V_LOG_QUERY, N'@<#=Context.Table.Name#>_Id BIGINT', @<#=Context.Table.Name#>_Id;

				END

				DELETE FROM [<#=Context.Table.Name#>] WHERE [<#=Context.Table.Name#>].[<#=Context.Table.Name#>_Id] = @<#=Context.Table.Name#>_Id;

				SET @V_ROWCOUNT = @@ROWCOUNT;
			END

		COMMIT TRANSACTION;

		SELECT @V_ROWCOUNT;

	END TRY
	BEGIN CATCH

		IF XACT_STATE() != 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		DECLARE @V_NOW DATETIME2(3) = GETDATE();
		DECLARE @V_ERROR_MESSAGE VARCHAR(MAX) = ERROR_MESSAGE();
		DECLARE @V_ERROR_SEVERITY INT = ERROR_SEVERITY();
		DECLARE @V_ERROR_STATE INT = ERROR_STATE();

		-- RAISE() must be called before EXEC [ProcessErrorLog_Save] in order to get the error
		-- on the first result in the SqlDataReader (Save stored procedures return 1 row).

		RAISERROR(@V_ERROR_MESSAGE, @V_ERROR_SEVERITY, @V_ERROR_STATE);

		EXEC [ProcessErrorLog_Save]
			 @ProcessErrorLog_Date = @V_NOW,
			 @ProcessErrorLog_ProcedureName = N'<#=Context.Table.Name#>_Delete',
			 @ProcessErrorLog_ErrorMessage = @V_ERROR_MESSAGE,
			 @ProcessErrorLog_ErrorSeverity = @V_ERROR_SEVERITY,
			 @ProcessErrorLog_ErrorState = @V_ERROR_STATE,
			 @ProcessErrorLog_Data = NULL,
			 @CtxUser = @CtxUser,
			 @CtxCulture = @CtxCulture,
			 @CtxWithContextSecurity = @CtxWithContextSecurity;

		RETURN (@@ROWCOUNT);

	END CATCH
END