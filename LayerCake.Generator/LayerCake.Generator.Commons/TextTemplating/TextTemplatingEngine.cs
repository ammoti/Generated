// -----------------------------------------------
// This file is part of the LayerCake Generator.
// 
// Copyright (c) 2012, 2015 LayerCake Generator.
// http://www.layercake-generator.net
// -----------------------------------------------

namespace LayerCake.Generator.Commons
{
	using System;
	using System.CodeDom.Compiler;
	using System.Collections.Concurrent;
	using System.Collections.Generic;
	using System.IO;
	using System.Linq;

	using Microsoft.VisualStudio.TextTemplating;

	[Serializable]
	public class TextTemplatingEngine
	{
		#region [ Members ]

		[field: NonSerialized()] // CA2235 : Mark all non-serializable fields - Field 'TextTemplatingEngine._engine' is a member of type 'TextTemplatingEngine', which is serializable, but is of type 'TextTemplatingEngine', which is not serializable. Add the NonSerializedAttribute to 'TextTemplatingEngine._engine'
		private readonly Engine _engine = null;

		private readonly TextTemplatingEngineHost _host = null;

		private readonly ConcurrentBag<TextTemplatingOutputFileDefinition> _generatedFiles = null;

		#endregion

		#region [ Events ]

		[field: NonSerialized()]
		public event TextTemplatingEngineProcessingDelegate OnProcessing;

		[field: NonSerialized()]
		public event TextTemplatingEngineProcessedDelegate OnProcessed;

		[field: NonSerialized()]
		public event TextTemplatingEngineNotProcessedDelegate OnNotProcessed;

		[field: NonSerialized()]
		public event TextTemplatingEngineProcessFailedDelegate OnProcessFailed;

		[field: NonSerialized()]
		public event TextTemplatingEngineGeneratedFileDelegate OnGeneratedFile;

		#endregion

		#region [ Constructor ]

		/// <summary>
		/// Constructor.
		/// </summary>
		/// 
		/// <param name="templateDir">
		/// Path where are located the T4 Templates.
		/// </param>
		/// 
		/// <param name="solutionDir">
		/// Path where is located the Visual Studio solution (where is located the LayerCake Generator Configuration File (Domain.CompanyName.ProjectName.config)).
		/// </param>
		public TextTemplatingEngine(string solutionDir, string templateDir)
		{
			_engine = new Engine();
			_host = new TextTemplatingEngineHost(solutionDir, templateDir);
			_generatedFiles = new ConcurrentBag<TextTemplatingOutputFileDefinition>();
		}

		#endregion

		#region [ Public Methods ]

		/// <summary>
		/// Execute the process.
		/// </summary>
		/// 
		/// <param name="parameters">
		/// Parameters.
		/// </param>
		/// 
		/// <param name="tmpOutputFilePath">
		/// Path of the output file generated by the call.
		/// </param>
		/// 
		/// <returns>
		/// The ProcessStateEnum state.
		/// </returns>
		public ProcessStateEnum Process(TextTemplatingParameters parameters, out string tmpOutputFilePath)
		{
			tmpOutputFilePath = null;

			if (!parameters.OverrideIfExists && File.Exists(parameters.OutputFilePath))
			{
				if (this.OnNotProcessed != null)
					this.OnNotProcessed(this, new TextTemplatingEngineTemplateEventArgs(parameters.TemplateFilePath));

				return ProcessStateEnum.NotProcessed;
			}

			if (this.OnProcessing != null)
				this.OnProcessing(this, new TextTemplatingEngineTemplateEventArgs(parameters.TemplateFilePath));

			_host.TemplateFile = parameters.TemplateFilePath;

			string input = File.ReadAllText(parameters.TemplateFilePath);
			string output = _engine.ProcessTemplate(input, _host);

			if (this.Errors.Count() != 0 || output.Equals("ErrorGeneratingOutput", StringComparison.InvariantCultureIgnoreCase))
			{
				if (this.OnProcessFailed != null)
					this.OnProcessFailed(this, new TextTemplatingEngineTemplateEventArgs(parameters.TemplateFilePath));

				return ProcessStateEnum.Failed;
			}

			var fileDefinition = new TextTemplatingOutputFileDefinition(parameters.OutputFilePath, parameters.AddToProject);
			_generatedFiles.Add(fileDefinition);

			File.WriteAllText(fileDefinition.TempPath, output.TrimStart('\r', '\n'), _host.FileEncoding);

			tmpOutputFilePath = fileDefinition.TempPath;

			if (this.OnProcessed != null)
				this.OnProcessed(this, new TextTemplatingEngineTemplateEventArgs(parameters.TemplateFilePath));

			return ProcessStateEnum.Processed;
		}

		/// <summary>
		/// Attach the generated files if the process is successful.
		/// </summary>
		public void AttachGeneratedFiles()
		{
			if (this.Errors.IsNullOrEmpty())
			{
				foreach (var file in _generatedFiles)
				{
					FileHelper.TryMove(file.TempPath, file.Path); // -> override files
				}

				VisualStudioHelper.AddToProject(
					_generatedFiles.Where(i => i.AddToProject).Select(f => f.Path),
					(file) =>
					{
						if (this.OnGeneratedFile != null)
							this.OnGeneratedFile(this, new TextTemplatingEngineFileGeneratedEventArgs(file, true));
					});
			}
		}

		/// <summary>
		/// Delete all temp files.
		/// </summary>
		public void Clear()
		{
			foreach (var file in _generatedFiles)
			{
				FileHelper.TryDelete(file.TempPath);
			}
		}

		/// <summary>
		/// Sets the TextTemplatingEngine parameters.
		/// </summary>
		/// 
		/// <param name="parameters">
		/// Parameters.
		/// </param>
		public void SetParameters(IDictionary<string, object> parameters)
		{
			if (parameters != null)
			{
				_host.Session.Clear();

				foreach (var parameter in parameters)
				{
					_host.Session.Add(parameter.Key, parameter.Value);
				}
			}
		}

		#endregion

		#region [ Properties ]

		/// <summary>
		/// Gets the list of the generated files by the process.
		/// </summary>
		public IEnumerable<TextTemplatingOutputFileDefinition> GeneratedFiles
		{
			get { return _generatedFiles.AsEnumerable(); }
		}

		/// <summary>
		/// Value indicating whether the process has errors.
		/// </summary>
		public bool HasErrors
		{
			get { return !this.Errors.IsNullOrEmpty(); }
		}

		/// <summary>
		/// Value indicating whether the process has warnings.
		/// </summary>
		public bool HasWarnings
		{
			get { return !this.Warnings.IsNullOrEmpty(); }
		}

		/// <summary>
		/// Gets the errors of the TextTemplatingEngineHost host that processes T4 Templates.
		/// </summary>
		public IEnumerable<CompilerError> Errors
		{
			get
			{
				IList<CompilerError> errors = new List<CompilerError>(_host.Errors.Count);
				foreach (CompilerError error in _host.Errors)
				{
					if (!error.IsWarning)
					{
						errors.Add(error);
					}
				}

				return errors;
			}
		}

		/// <summary>
		/// Gets the warnings of the TextTemplatingEngineHost host that processes T4 Templates.
		/// </summary>
		public IEnumerable<CompilerError> Warnings
		{
			get
			{
				IList<CompilerError> warnings = new List<CompilerError>(_host.Errors.Count);
				foreach (CompilerError warning in _host.Errors)
				{
					if (warning.IsWarning)
					{
						warnings.Add(warning);
					}
				}

				return warnings;
			}
		}

		#endregion
	}
}
